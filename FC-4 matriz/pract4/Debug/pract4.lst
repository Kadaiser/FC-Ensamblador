
pract4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bss          000002a0  0c000000  0c000000  00008000  2**2
                  ALLOC
  1 .text         000002d8  0c0002a0  0c0002a0  000002a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.attributes 0000002e  00000000  00000000  00000578  2**0
                  CONTENTS, READONLY
  3 .comment      0000002a  00000000  00000000  000005a6  2**0
                  CONTENTS, READONLY
  4 .debug_line   0000042d  00000000  00000000  000005d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000004a5  00000000  00000000  000009fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000021a  00000000  00000000  00000ea2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000080  00000000  00000000  000010c0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_macinfo 00006cae  00000000  00000000  00001140  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000240  00000000  00000000  00007dee  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000000ae  00000000  00000000  0000802e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubtypes 00000060  00000000  00000000  000080dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000156  00000000  00000000  0000813c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000000dc  00000000  00000000  00008294  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c0002a0 <start>:
    .extern main
    .extern _stack
	.global start

start:
    ldr sp,=_stack
 c0002a0:	e59fd008 	ldr	sp, [pc, #8]	; c0002b0 <End+0x4>
    mov fp,#0
 c0002a4:	e3a0b000 	mov	fp, #0
    
    bl main
 c0002a8:	eb00001d 	bl	c000324 <main>

0c0002ac <End>:

End:
    B End
 c0002ac:	eafffffe 	b	c0002ac <End>
 c0002b0:	0c7ff000 	.word	0x0c7ff000

0c0002b4 <initRGB>:
pixelRGB imagenRGB[N][M];
int imagenGris[N][M];
int imagenBinaria[N][M];
int unosPorFila[N];

void initRGB(pixelRGB m[N][M], int nfilas, int ncols) {
 c0002b4:	e92d0070 	push	{r4, r5, r6}

    int i,j;
    
    for (i=0;i<nfilas;i++)
 c0002b8:	e3510000 	cmp	r1, #0
 c0002bc:	da000016 	ble	c00031c <initRGB+0x68>
pixelRGB imagenRGB[N][M];
int imagenGris[N][M];
int imagenBinaria[N][M];
int unosPorFila[N];

void initRGB(pixelRGB m[N][M], int nfilas, int ncols) {
 c0002c0:	e0811101 	add	r1, r1, r1, lsl #2
 c0002c4:	e0815101 	add	r5, r1, r1, lsl #2
 c0002c8:	e3a04000 	mov	r4, #0

    int i,j;
    
    for (i=0;i<nfilas;i++)
        for (j=0; j<ncols; j++) {
 c0002cc:	e1a06004 	mov	r6, r4
 c0002d0:	ea00000b 	b	c000304 <initRGB+0x50>
            m[i][j].R = (i+j)*FACTOR;
 c0002d4:	e5813000 	str	r3, [r1]
            m[i][j].G = (i+j)*FACTOR;
 c0002d8:	e5813004 	str	r3, [r1, #4]
            m[i][j].B = (i+j)*FACTOR;
 c0002dc:	e5813008 	str	r3, [r1, #8]
void initRGB(pixelRGB m[N][M], int nfilas, int ncols) {

    int i,j;
    
    for (i=0;i<nfilas;i++)
        for (j=0; j<ncols; j++) {
 c0002e0:	e28cc001 	add	ip, ip, #1
 c0002e4:	e2833019 	add	r3, r3, #25
 c0002e8:	e281100c 	add	r1, r1, #12
 c0002ec:	e15c0002 	cmp	ip, r2
 c0002f0:	1afffff7 	bne	c0002d4 <initRGB+0x20>
 c0002f4:	e2844019 	add	r4, r4, #25
 c0002f8:	e2800030 	add	r0, r0, #48	; 0x30

void initRGB(pixelRGB m[N][M], int nfilas, int ncols) {

    int i,j;
    
    for (i=0;i<nfilas;i++)
 c0002fc:	e1540005 	cmp	r4, r5
 c000300:	0a000005 	beq	c00031c <initRGB+0x68>
        for (j=0; j<ncols; j++) {
 c000304:	e3520000 	cmp	r2, #0
 c000308:	c1a01000 	movgt	r1, r0
 c00030c:	c1a03004 	movgt	r3, r4
 c000310:	c1a0c006 	movgt	ip, r6
 c000314:	caffffee 	bgt	c0002d4 <initRGB+0x20>
 c000318:	eafffff5 	b	c0002f4 <initRGB+0x40>
            m[i][j].R = (i+j)*FACTOR;
            m[i][j].G = (i+j)*FACTOR;
            m[i][j].B = (i+j)*FACTOR;
            //(i+j)*FACTOR
        }
}
 c00031c:	e8bd0070 	pop	{r4, r5, r6}
 c000320:	e12fff1e 	bx	lr

0c000324 <main>:



int main() {
 c000324:	e1a0c00d 	mov	ip, sp
 c000328:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 c00032c:	e24cb004 	sub	fp, ip, #4
    
    // 1. Crear una matriz NxM de diferentes colores

	initRGB(imagenRGB,N,M);
 c000330:	e59f4060 	ldr	r4, [pc, #96]	; c000398 <main+0x74>
 c000334:	e1a00004 	mov	r0, r4
 c000338:	e3a01008 	mov	r1, #8
 c00033c:	e3a02004 	mov	r2, #4
 c000340:	ebffffdb 	bl	c0002b4 <initRGB>

	// 2. Traducir la matriz RGB a una matriz de grises

    RGB2GrayMatrix(imagenRGB,imagenGris,N,M);
 c000344:	e59f5050 	ldr	r5, [pc, #80]	; c00039c <main+0x78>
 c000348:	e1a00004 	mov	r0, r4
 c00034c:	e1a01005 	mov	r1, r5
 c000350:	e3a02008 	mov	r2, #8
 c000354:	e3a03004 	mov	r3, #4
 c000358:	eb000063 	bl	c0004ec <RGB2GrayMatrix>

    // 3. Traducir la matriz de grises a una matriz en blanco y negro

    Gray2BinaryMatrix(imagenGris,imagenBinaria,N,M);
 c00035c:	e59f403c 	ldr	r4, [pc, #60]	; c0003a0 <main+0x7c>
 c000360:	e1a00005 	mov	r0, r5
 c000364:	e1a01004 	mov	r1, r4
 c000368:	e3a02008 	mov	r2, #8
 c00036c:	e3a03004 	mov	r3, #4
 c000370:	eb000023 	bl	c000404 <Gray2BinaryMatrix>

    // Contar los unos que aparecen por filas en la matriz de blanco y negro

    contarUnos(imagenBinaria,unosPorFila,N,M);
 c000374:	e1a00004 	mov	r0, r4
 c000378:	e59f1024 	ldr	r1, [pc, #36]	; c0003a4 <main+0x80>
 c00037c:	e3a02008 	mov	r2, #8
 c000380:	e3a03004 	mov	r3, #4
 c000384:	eb000007 	bl	c0003a8 <contarUnos>

    return 0;
}
 c000388:	e3a00000 	mov	r0, #0
 c00038c:	e24bd014 	sub	sp, fp, #20
 c000390:	e89d6830 	ldm	sp, {r4, r5, fp, sp, lr}
 c000394:	e12fff1e 	bx	lr
 c000398:	0c000000 	.word	0x0c000000
 c00039c:	0c000220 	.word	0x0c000220
 c0003a0:	0c000180 	.word	0x0c000180
 c0003a4:	0c000200 	.word	0x0c000200

0c0003a8 <contarUnos>:
R2	VALOR DEL NUMERO DE FILAS DE LA MATRIZ
R3	VALOR DEL NUMERO DE COLUMNAS DE LA MATRIZ
*/

contarUnos:
  		PUSH {R4,R5,R6,R7,R8}	//prologo, subrutina hoja, 2 variabes locales "i" "j", no retorna resultado
 c0003a8:	e92d01f0 	push	{r4, r5, r6, r7, r8}
 		MOV R4, #0				//inicializar "i"
 c0003ac:	e3a04000 	mov	r4, #0
 		MOV R5, #0				//auxiliar de intercambio a 0 | auxiliar de nº de 1 en fila
 c0003b0:	e3a05000 	mov	r5, #0
 		MOV R6, #0				//INICIALIZAR "j"
 c0003b4:	e3a06000 	mov	r6, #0

0c0003b8 <bucleI>:
 bucleI:
 		CMP R4, R2 				//for (i=0;i<nfilas;i++)
 c0003b8:	e1540002 	cmp	r4, r2
		BGE finbucleI
 c0003bc:	aa00000e 	bge	c0003fc <finbucleI>
 		STR	R5, [R1,R4,LSL#2] 	// vector[i]=0
 c0003c0:	e7815104 	str	r5, [r1, r4, lsl #2]

0c0003c4 <bucleJ>:

 bucleJ:
 		CMP R6, R3
 c0003c4:	e1560003 	cmp	r6, r3
 		BGE finbucleJ			//for (j=0; j<ncols; j++)
 c0003c8:	aa000008 	bge	c0003f0 <finbucleJ>
		MUL R7, R4, R2			//R7 = i * nfilas
 c0003cc:	e0070294 	mul	r7, r4, r2
		ADD R7, R7, R6			//R7 = i * nfilas+ j  (posicion del elemento en la matriz tomada unidimensionalmente)
 c0003d0:	e0877006 	add	r7, r7, r6
		LDR R8, [R0,R7,LSL#2]	//R8 = mat[i][j]
 c0003d4:	e7908107 	ldr	r8, [r0, r7, lsl #2]
		CMP R8, #1				// if(mat[i][j] == 1)
 c0003d8:	e3580001 	cmp	r8, #1
		BNE not1
 c0003dc:	1a000001 	bne	c0003e8 <not1>
		ADD R5, R5, #1			//incremento del numero de 1 encontrados
 c0003e0:	e2855001 	add	r5, r5, #1
		STR R5, [R1,R4,LSL#2]	//vector[i]++
 c0003e4:	e7815104 	str	r5, [r1, r4, lsl #2]

0c0003e8 <not1>:
not1:
		ADD R6, R6, #1			//incrementar contador j
 c0003e8:	e2866001 	add	r6, r6, #1
		B bucleJ
 c0003ec:	eafffff4 	b	c0003c4 <bucleJ>

0c0003f0 <finbucleJ>:

finbucleJ:
		MOV R6, #0 				//reinicar contador "j"
 c0003f0:	e3a06000 	mov	r6, #0
 		ADD R4, R4, #1			//icrementar contador "i"
 c0003f4:	e2844001 	add	r4, r4, #1
 		B bucleI
 c0003f8:	eaffffee 	b	c0003b8 <bucleI>

0c0003fc <finbucleI>:

finbucleI:
		POP {R4,R5,R6,R7,R8}	//epílogo
 c0003fc:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
  		bx lr
 c000400:	e12fff1e 	bx	lr

0c000404 <Gray2BinaryMatrix>:
        for (j=0; j<ncols; j++)
            dest[i][j] =  rgb2gray(orig[i][j]);
    
}

void Gray2BinaryMatrix(int orig[N][M], int dest[N][M], int nfilas, int ncols) {
 c000404:	e92d07f0 	push	{r4, r5, r6, r7, r8, r9, sl}
 c000408:	e24dd00c 	sub	sp, sp, #12
    int i,j;
    int umbral = 127;
    
    for (i=0;i<nfilas;i++)
 c00040c:	e2529000 	subs	r9, r2, #0
 c000410:	da00001b 	ble	c000484 <Gray2BinaryMatrix+0x80>
 c000414:	e3a0a000 	mov	sl, #0
        for (j=0; j<ncols; j++)
 c000418:	e1a0500a 	mov	r5, sl
 c00041c:	e58da004 	str	sl, [sp, #4]
            if (orig[i][j] > umbral)
                dest[i][j]=1;
 c000420:	e3a08001 	mov	r8, #1
 c000424:	ea00000e 	b	c000464 <Gray2BinaryMatrix+0x60>
    int i,j;
    int umbral = 127;
    
    for (i=0;i<nfilas;i++)
        for (j=0; j<ncols; j++)
            if (orig[i][j] > umbral)
 c000428:	e7970002 	ldr	r0, [r7, r2]
                dest[i][j]=1;
 c00042c:	e3500080 	cmp	r0, #128	; 0x80
 c000430:	b1a00005 	movlt	r0, r5
 c000434:	a1a00008 	movge	r0, r8
 c000438:	e7860002 	str	r0, [r6, r2]
void Gray2BinaryMatrix(int orig[N][M], int dest[N][M], int nfilas, int ncols) {
    int i,j;
    int umbral = 127;
    
    for (i=0;i<nfilas;i++)
        for (j=0; j<ncols; j++)
 c00043c:	e28cc001 	add	ip, ip, #1
 c000440:	e2822004 	add	r2, r2, #4
 c000444:	e15c0003 	cmp	ip, r3
 c000448:	1afffff6 	bne	c000428 <Gray2BinaryMatrix+0x24>
 c00044c:	e1a00004 	mov	r0, r4

void Gray2BinaryMatrix(int orig[N][M], int dest[N][M], int nfilas, int ncols) {
    int i,j;
    int umbral = 127;
    
    for (i=0;i<nfilas;i++)
 c000450:	e28aa001 	add	sl, sl, #1
 c000454:	e2811010 	add	r1, r1, #16
 c000458:	e2800010 	add	r0, r0, #16
 c00045c:	e15a0009 	cmp	sl, r9
 c000460:	0a000007 	beq	c000484 <Gray2BinaryMatrix+0x80>
        for (j=0; j<ncols; j++)
 c000464:	e3530000 	cmp	r3, #0
 c000468:	dafffff8 	ble	c000450 <Gray2BinaryMatrix+0x4c>
 c00046c:	e1a07000 	mov	r7, r0
 c000470:	e1a06001 	mov	r6, r1
 c000474:	e1a02005 	mov	r2, r5
 c000478:	e59dc004 	ldr	ip, [sp, #4]
 c00047c:	e1a04000 	mov	r4, r0
 c000480:	eaffffe8 	b	c000428 <Gray2BinaryMatrix+0x24>
            if (orig[i][j] > umbral)
                dest[i][j]=1;
            else
                 dest[i][j]=0;
    
}
 c000484:	e28dd00c 	add	sp, sp, #12
 c000488:	e8bd07f0 	pop	{r4, r5, r6, r7, r8, r9, sl}
 c00048c:	e12fff1e 	bx	lr

0c000490 <rgb2gray>:


int rgb2gray(pixelRGB pixel) {
 c000490:	e24dd010 	sub	sp, sp, #16
 c000494:	e28d3004 	add	r3, sp, #4
 c000498:	e8830007 	stm	r3, {r0, r1, r2}
    return  ( (2126*pixel.R + 7152*pixel.G + 722*pixel.B) /10000);
 c00049c:	e59d3008 	ldr	r3, [sp, #8]
 c0004a0:	e0631183 	rsb	r1, r3, r3, lsl #3
 c0004a4:	e0631301 	rsb	r1, r3, r1, lsl #6
 c0004a8:	e0802280 	add	r2, r0, r0, lsl #5
 c0004ac:	e0802102 	add	r2, r0, r2, lsl #2
 c0004b0:	e0603182 	rsb	r3, r0, r2, lsl #3
 c0004b4:	e1a02083 	lsl	r2, r3, #1
 c0004b8:	e0823201 	add	r3, r2, r1, lsl #4
 c0004bc:	e59d200c 	ldr	r2, [sp, #12]
 c0004c0:	e0821082 	add	r1, r2, r2, lsl #1
 c0004c4:	e0611201 	rsb	r1, r1, r1, lsl #4
 c0004c8:	e0822181 	add	r2, r2, r1, lsl #3
 c0004cc:	e0832082 	add	r2, r3, r2, lsl #1
 c0004d0:	e59f0010 	ldr	r0, [pc, #16]	; c0004e8 <rgb2gray+0x58>
 c0004d4:	e0c03092 	smull	r3, r0, r2, r0
 c0004d8:	e1a02fc2 	asr	r2, r2, #31
}
 c0004dc:	e0620640 	rsb	r0, r2, r0, asr #12
 c0004e0:	e28dd010 	add	sp, sp, #16
 c0004e4:	e12fff1e 	bx	lr
 c0004e8:	68db8bad 	.word	0x68db8bad

0c0004ec <RGB2GrayMatrix>:
//-----------------------------------------------------------------------------------
//Las funciones que se definan en ensamblador deberán borrarse de este fichero
//de otra manera habría dos definciones de la misma función
//-----------------------------------------------------------------------------------

void RGB2GrayMatrix(pixelRGB orig[N][M], int dest[N][M], int nfilas, int ncols) {
 c0004ec:	e1a0c00d 	mov	ip, sp
 c0004f0:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 c0004f4:	e24cb004 	sub	fp, ip, #4
 c0004f8:	e24dd00c 	sub	sp, sp, #12
 c0004fc:	e1a06003 	mov	r6, r3
    int i,j;
    
    for (i=0;i<nfilas;i++)
 c000500:	e3520000 	cmp	r2, #0
 c000504:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
 c000508:	c1a0a001 	movgt	sl, r1
 c00050c:	c1a09000 	movgt	r9, r0
 c000510:	c3a08000 	movgt	r8, #0
 c000514:	ca00000e 	bgt	c000554 <RGB2GrayMatrix+0x68>
 c000518:	ea000013 	b	c00056c <RGB2GrayMatrix+0x80>
        for (j=0; j<ncols; j++)
            dest[i][j] =  rgb2gray(orig[i][j]);
 c00051c:	e0843084 	add	r3, r4, r4, lsl #1
 c000520:	e0873103 	add	r3, r7, r3, lsl #2
 c000524:	e8930007 	ldm	r3, {r0, r1, r2}
 c000528:	ebffffd8 	bl	c000490 <rgb2gray>
 c00052c:	e4850004 	str	r0, [r5], #4

void RGB2GrayMatrix(pixelRGB orig[N][M], int dest[N][M], int nfilas, int ncols) {
    int i,j;
    
    for (i=0;i<nfilas;i++)
        for (j=0; j<ncols; j++)
 c000530:	e2844001 	add	r4, r4, #1
 c000534:	e1540006 	cmp	r4, r6
 c000538:	1afffff7 	bne	c00051c <RGB2GrayMatrix+0x30>
//-----------------------------------------------------------------------------------

void RGB2GrayMatrix(pixelRGB orig[N][M], int dest[N][M], int nfilas, int ncols) {
    int i,j;
    
    for (i=0;i<nfilas;i++)
 c00053c:	e2888001 	add	r8, r8, #1
 c000540:	e28aa010 	add	sl, sl, #16
 c000544:	e2899030 	add	r9, r9, #48	; 0x30
 c000548:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
 c00054c:	e1580003 	cmp	r8, r3
 c000550:	0a000005 	beq	c00056c <RGB2GrayMatrix+0x80>
        for (j=0; j<ncols; j++)
 c000554:	e3560000 	cmp	r6, #0
 c000558:	c1a07009 	movgt	r7, r9
 c00055c:	c1a0500a 	movgt	r5, sl
 c000560:	c3a04000 	movgt	r4, #0
 c000564:	caffffec 	bgt	c00051c <RGB2GrayMatrix+0x30>
 c000568:	eafffff3 	b	c00053c <RGB2GrayMatrix+0x50>
            dest[i][j] =  rgb2gray(orig[i][j]);
    
}
 c00056c:	e24bd028 	sub	sp, fp, #40	; 0x28
 c000570:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
 c000574:	e12fff1e 	bx	lr
